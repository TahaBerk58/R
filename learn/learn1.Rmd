---
title: "R Notebook"
output: html_notebook
---
# R Tutorial
- It is a great resource for data analysis, data visualization, data science and machine learning
- It provides many statistical techniques (such as statistical tests, classification, clustering and data reduction)
- It is easy to draw graphs in R, like pie charts, histograms, box plot, scatter plot, etc++
- It works on different platforms (Windows, Mac, Linux)
- It is open-source and free
- It has a large community support
- It has many packages (libraries of functions) that can be used to solve different problems
```{r}
# Print
for (x in 1:10){
  print(x)
}
```
```{r}
# Variables
name <- "Taha Berk"
age <- 21

name
age
```
```{r}
# Concatenate Elements
text <- "awsome"

paste("Ceren", text)

text1 <- "Ceren"
text2 <- "awsome"

paste(text1, text2)
```
```{r}
var1 <- var2 <- var3 <- var4 <- "orange"

var1
var2
var3
var4
```
# Basic Data Types

Basic data types in R can be divided into the following types:

- numeric - (10.5, 55, 787)
- integer - (1L, 55L, 100L, where the letter "L" declares this as an integer)
- complex - (9 + 3i, where "i" is the imaginary part)
- character (a.k.a. string) - ("k", "R is exciting", "FALSE", "11.5")
- logical (a.k.a. boolean) - (TRUE or FALSE)

We can use the class() function to check the data type of a variable:
```{r}
# Data Types
# numeric
x <- 10.5
class(x)

# integer
x <- 1000L
class(x)

# complex
x <- 9i + 3
class(x)

# character/string
x <- "R is exciting"
class(x)

# logical/boolean
x <- TRUE
class(x)
```
# Type Conversion

You can convert from one type to another with the following functions:

- as.numeric()
- as.integer()
- as.complex()
```{r}
x <- 1L # integer
y <- 2 # numeric

# convert from integer to numeric:
a <- as.numeric(x)

# convert from numeric to integer:
b <- as.integer(y)

# print values of x and y
x
y

# print the class name of a and b
class(a)
class(b)
```

---

# Built-in Math Functions

R also has many built-in math functions that allows you to perform mathematical tasks on numbers.

For example, the `min()` and `max()` functions can be used to find the lowest or highest number in a set:

### sqrt()
The `sqrt()` function returns the square root of a number:

### abs()
The `abs()` function returns the absolute (positive) value of a number:

### ceiling() and floor()
The `ceiling()` function rounds a number upwards to its nearest integer, and the `floor()` function rounds a number downwards to its nearest integer, and returns the result:

---

# String Literals
`"hello"` is the same as `'hello'`:

## Multiple Strings
```{r}
str <- "Taha,
Berk,
Terekli"

str
```

- If you want the line breaks inserted at the same position as in the code, use the `cat()` function:
```{r}
str <- "Taha,
Berk,
Terekli"

cat(str)
```
# String Length
```{r}
str <- "Taha Berk"
nchar(str)
```
# Check a String
```{r}
str <- "Taha Berk"

grepl("T", str)
grepl("Taha", str)
grepl("C", str)
```
# Escape Characters
To insert characters that are illegal in a string, you must use an escape character.
An escape character is a backslash \ followed by the character you want to insert.
An example of an illegal character is a double quote inside a string that is surrounded by double quotes:
```{r}
str <- "We are the so-called \"Vikings\", from the north."

str
cat(str)
```

---

# Boolean (Logical Values)
```{r}
10 > 9    # TRUE because 10 is greater than 9
10 == 9   # FALSE because 10 is not equal to 9
10 < 9    # FALSE because 10 is greater than 9
```
```{r}
a <- 200
b <- 33

if (b > a) {
  print ("b is greater than a")
} else {
  print("b is not greater than a")
}
```

---

# If, Else If, Else Statement
```{r}
a <- 200
b <- 33

if (b > a) {
  print("b is greater than a")
} else if (a == b) {
  print("a and b are equal")
} else {
  print("a is greater than b")
}
```
## R Nested If
```{r}
x <- 17

if (x > 10) {
  print("Above ten")
  if (x > 20) {
    print("and also above 20!")
  } else {
    print("but not above 20.")
  }
} else {
  print("below 10.")
}
```
## And
The `&` symbol (and) is a logical operator, and is used to combine conditional statements:
```{r}
a <- 200
b <- 33
c <- 500

if (a > b & c > a) {
  print("Both conditions are true")
}
```
## Or
The `|` symbol (or) is a logical operator, and is used to combine conditional statements:
```{r}
a <- 200
b <- 33
c <- 500

if (a > b | a > c) {
  print("At least one of the conditions is true")
}
```

---

# Loops
Loops can execute a block of code as long as a specified condition is reached.
Loops are handy because they save time, reduce errors, and they make code more readable.
R has two loop commands:

- `while` loops
- `for` loops

### While Loop
With the `while` loop we can execute a set of statements as long as a condition is TRUE:
```{r}
i <- 1
while (i < 6) {
  print(i)
  i <- i + 1
}
```
## For Loop
A `for` loop is used for iterating over a sequence:
```{r}
for (x in 1:10) {
  print(x)
}
```
```{r}
fruits <- list("apple", "banana", "cherry")

for (x in fruits) {
  print(x)
}
```
#### Break
With the `break` statement, we can stop the loop even if the while condition is TRUE:
```{r}
i <- 1
while (i < 6) {
  print(i)
  i <- i + 1
  if (i == 4) {
    break
  }
}
```
```{r}
fruits <- list("apple", "banana", "cherry")

for (x in fruits) {
  if (x == "cherry") {
    break
  }
  print(x)
}
```

#### Next
With the `next` statement, we can skip an iteration without terminating the loop:
```{r}
i <- 0
while (i < 6) {
  i <- i + 1
  if (i == 3) {
    next
  }
  print(i)
}
```
```{r}
fruits <- list("apple", "banana", "cherry")

for (x in fruits) {
  if (x == "banana") {
    next
  }
  print(x)
}
```
### Nested Loops
It is also possible to place a loop inside another loop. This is called a *nested loop*:
```{r}
adj <- list("red", "big", "tasty")

fruits <- list("apple", "banana", "cherry")
  for (x in adj) {
    for (y in fruits) {
      print(paste(x, y))
  }
}
```

---

# R Functions
A function is a block of code which only runs when it is called.
You can pass data, known as parameters, into a function.
A function can return data as a result.
#### Call a Funcion
```{r}
my_function <- function() {
  print("Hello World!")
}

my_function() # call the function named my_function
```
#### Arguments
```{r}
my_function <- function(fname) {
  paste(fname, "Griffin")
}

my_function("Peter")
my_function("Lois")
my_function("Stewie")
```
#### Number of Arguments
```{r}
my_function <- function(fname, lname) {
  paste(fname, lname)
}

my_function("Peter", "Griffin")
```
#### Defalut Parameter Value
```{r}
my_function <- function(country = "Norway") {
  paste("I am from", country)
}

my_function("Sweden")
my_function("India")
my_function() # will get the default value, which is Norway
my_function("USA")
```
#### Return Values
To let a function return a result, use the `return()` function:
```{r}
my_function <- function(x) {
  return (5 * x)
}

print(my_function(3))
print(my_function(5))
```
#### Nested Functions
There are two ways to create a nested function:

- Call a function within another function.
- Write a function within a function.
```{r}
Nested_function <- function(x, y) {
  a <- x + y
  return(a)
}

Nested_function(Nested_function(2,2), Nested_function(3,3))
```
```{r}
Outer_func <- function(x) {
  Inner_func <- function(y) {
    a <- x + y
    return(a)
  }
  return (Inner_func)
}
output <- Outer_func(3) # To call the Outer_func
output(5)
```
#### Recursion
R also accepts function recursion, which means a defined function can call itself.

Recursion is a common mathematical and programming concept. It means that a function calls itself. This has the benefit of meaning that you can loop through data to reach a result.

The developer should be very careful with recursion as it can be quite easy to slip into writing a function which never terminates, or one that uses excess amounts of memory or processor power. However, when written correctly, recursion can be a very efficient and mathematically-elegant approach to programming.
```{r}
tri_recursion <- function(k) {
  if (k > 0) {
    result <- k + tri_recursion(k - 1)
    print(result)
  } else {
    result = 0
    return(result)
  }
}
tri_recursion(6)
```
#### Global Variables
Variables that are created outside of a function are known as global variables.

Global variables can be used by everyone, both inside of functions and outside.
```{r}
txt <- "awesome"
my_function <- function() {
  paste("R is", txt)
}

my_function()
```
```{r}
txt <- "global variable"
my_function <- function() {
  txt = "fantastic"
  paste("R is", txt)
}

my_function()

txt # print txt
```

